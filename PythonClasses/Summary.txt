== 1 Classes & Instances ==
    - methods : functions within Classes
    - attributes : properties that a Class have
        - also known as instance variables

    
``` Overall Code Syntax ``` -----------------------------------------------------------------------------------------
    
    class Employee:

        num_employees = 0
        raise_amount = 1.04 # class variable
        
        def __init__(self, first, last, pay):
            self.first = first
            self.last = last
            self.pay = pay
            self.email = first + "." + last + "@company.com"
            Employee.num_employees += 1 # Want to modify for all instances

        def get_fullName(self):
            return '{} {}'.format(self.first, self.last)

        def apply_raise(self):
            self.pay = int(self.pay * self.raise_amount) # if self used, only instance raise_amount is modified
            # self.pay = int(self.pay * Employee.raise_amount) # if Employee used, all instance raise_amount modified

        @classmethod
        def set_raise_amt(cls, amount):
            cls.raise_amount = amount


        @classmethod # Alternative Constructor to parse string input
        def from_string(cls, emp_string):
            first, last, pay = emp_string.split('-')
            return cls(first, last, pay)

        @staticmethod
        def is_workday(day):
            # Monday = 0
            # Sunday = 6
            if day.weekday() == 5 or day.weekday() == 6:
                return False
            return True



    emp_1 = Employee("Lucas", "Leow", 10000)
    print(emp_1.get_fullName)
    print(Employee.fullName(emp_1))

    print(emp1.__dict__) # Accessing object namespace
    print(Employee.__dict__) # Accessing class namespace
    

    Employee.set_raise_amt(1.05)

    str1 = "John-Doe-70000"
    emp_parsed = Employee.from_string(str1) # Alternative Constructor concept (search below for details)


    # Static method example(see below for details)
    import datetime
    mydate = datetime.date(2023, 7, 14)

    print(Employee.is_workday(mydate))



``` ----------------------------------------------------------------------------------------------------------------- ```



    - Class = blueprint for creating instances (objects)

    - __init__ is used as constructor for python Classes
    - when creating methods within class, it receives instance of class as first argument automatically
        - by convention, named as "self"

    - 2 ways to call methods:

        1) Through each instance
            - emp1.get_fullName()

        2) Through Class
            - Employee.get_fullName(emp1)


== 2 Class Variables ==

    - variables shared among all instance of class
        eg:
            - pay_raise
            - num_students
            - num_shapes
            - num_animals
            etc.

    - Instance Variables -
        - unique for each instance
            - color
            - size
            - height
            - age
            etc.

    - Access Class variables via:
        - Class itself
            Employee.raise_amount
        - Instance of a Class
            self.raise_amount
                - will first check if the instance has the attribute
                - next, will check if the class has attribute
                - next, if inherited, will check parent class for attribute

    - Access namespace of objects:
        - print(emp1.__dict__)


    ** Modifying Class Variables **

        Employee.raise_amount = 1.05
            - changes value for all instances
        
        emp_1.raise_amount = 1.05
            - only changes value for emp_1 instance
            - creates raise_amount instance variable for emp_1
                - no longer dealing with the class variable

            * Important concept
                - sometimes only want to change value for certain instance
                - eg: increasing pay rate only for emp_1 instead of all Employees


== 3 Class methods & Static methods ==
    
    -- Class methods --
        - takes in class as 1st argument instead of instance (self) as 1st argument
        - using @classmethod decorator
        - convention is "cls" for class argument


                @classmethod
                def set_raise_amt(cls, amount):
                    cls.raise_amount = amount


                Employee.set_raise_amt(1.05)
                    - alter class variable

                emp1.set_raise_amt(1.05)
                    - still alters class variable

    
    -- Class methods as alternative constructors -- 
        - using class method to create objects
        - eg: to parse string input into instance variables

            str1 = "John-Doe-70000"
            str2 = "Jane-Smith-30000"
            str3 = "Bob-Michael-50000"
            
        * convention is to prefix alternative constructor with "from"

        @classmethod
        def from_string(cls, emp_string):
            first, last, pay = emp_string.split('-')
            return cls(first, last, pay)

        emp_parsed = Employee.from_string(str1)


        -- Static Methods --
            - Dont pass anything to method automatically (no self / cls)
            - using @staticmethod decorator
            - used when instance or class not required within class 
                 - but work performed still relevant to class
            - accessed using Class
                - Employee.is_workday()


            @staticmethod
            def is_workday(day):
                # Monday = 0
                # Sunday = 6
                if day.weekday() == 5 or day.weekday() == 6:
                    return False
                return True
            
            import datetime
            mydate = datetime.date(2023, 7, 14)
            print(Employee.is_workday(mydate))

